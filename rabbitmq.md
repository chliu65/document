# RabbitMQ

### 1.消息队列

使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。目前使用较多的消息队列有ActiveMQ，RabbitMQ，Kafka，RocketMQ。缺点是提高了系统的复杂性，需要确保消息传输的可靠性、不重复消费、消息队列的高可用。（类似nio的概念）

### 2.JMS与AMQP

![image-20200810103402251](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200810103402251.png)

### 3.常见消息队列对比

![image-20200810103516632](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200810103516632.png)

事务消息支持：

### 4.RabbitMQ

**消息传输**

由于TCP连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ使用信道的方式来传输数据。信道是建立在真实的TCP连接内的虚拟连接，且每条TCP连接上的信道数量没有限制。

**路由**

- direct：如果路由键完全匹配，消息就被投递到相应的队列
- fanout：如果交换器收到消息，将会广播到所有绑定的队列上
- topic：可以使来自不同源头的消息能够到达同一个队列。 使用topic交换器时，可以使用通配符，

**消息可靠传递保证**

发送端：

发送方确认模式，消息会被指派唯一id，一旦投递到目的队列或被持久化之后，信道发送一个确认给生产者。当rabbitmq内部错误导致消息丢失，会发送那仓库。发送方确认是异步的。

消费端：

接收方确认机制。消费者接受后进行确认，确认后才会移除该消息。这里并没有用到超时机制，RabbitMQ仅通过Consumer的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ给了Consumer足够长的时间来处理消息。

- 如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要根据bizId去重）
- 如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该消费者分发更多的消息。
- 消费超时或消费抛异常，

**死信队列**

1. 消息被拒绝（Basic.Reject或Basic.Nack）并且设置 requeue 参数的值为 false

2. 消息过期了

3. 队列达到最大的长度

   可以用来模拟延迟队列