# Redis

### 1.redis简介

 **使用 C 语言开发的非关系型数据库，数据存放在内存中，读写速度快，支持事务、持久化、集群等。**

### **2.单线程运行快速的原因**

**纯内存访问**

**非阻塞IO**

**单线程避免了线程切换和线程竞争状态产生的消耗**

### 3.redis的IO多路复用模式

Redis 基于 Reactor 模式（https://www.cnblogs.com/winner-0715/p/8733787.html）开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据 套接字目前执行的任务来为套接字关联不同的事件处理器。

**当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。**

**虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字**，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。

![img](https://github.com/Snailclimb/JavaGuide/raw/master/docs/database/Redis/images/redis-all/redis%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8.png)

###  **4.过期的数据的删除策略**

1. **惰性删除** ：只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会造成太多过期 key 没有被删除。
2. **定期删除** ： 每隔一段时间抽取一批 key 执行删除过期key操作。并且，Redis 底层会并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。

### 5.Redis 内存淘汰机制

Redis 提供 6 种数据淘汰策略：

1. **volatile-lru（least frequently used）**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. **allkeys-lru（least recently used）**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）
5. **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰
6. **no-eviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！

4.0 版本后增加以下两种：

1. **volatile-lfu**：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰
2. **allkeys-lfu**：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key

### 6.持久化机制

##### **RDB

把当前进程数据生成快照文件保存在硬盘。

生成快照文件执行bgsave，父进程判断是否有正在进行持久化操作的子进程，有的话直接返回。

父进程fork出一个子进程，此期间父进程读写数据阻塞

子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后原子替换原RDB文件，此期间父进程接收客户端读写请求。

子进程发送完成信号。

优点：加载快

##### **AOF**

以独立日志的形式记录写命令，恢复时重新执行写命令。

命令写入→文件同步→文件重写→重启加载

AOF重写：

随着命令不断写入，AOF文件越来越大，需要重写以压缩文件体积。

如果当前正在AOF重写，则返回。

fork子进程，父进程阻塞。

子进程重写AOF，父进程接收客户端指令，并将指令存储到重写缓存区。

子进程完成AOF重写，将缓存区内容添加到AOF文件末尾。替换 原AOF文件

**混合持久化**

RDB写在AOF的开头

### 7.基础数据结构

  **跳表**

解决普通链表查找慢的问题，时间复杂度对数级

由多个层的链表组成，查询时从高层往低层查找。

每个节点随机出一个层数

### 8.缓存穿透与缓存雪崩

**缓存穿透**

大量无效key穿过redis打到数据库

可以缓存无效key或布隆过滤器

缓存雪崩

大量key同时失效

设置过期时间随机

### 9.redis高可用

**redis主从复制**

复制过程：

从节点执行slaveof指令，从节点保存主节点地址信息ip+port。

从节点与主节点建立socket连接

发送ping命令，无反应则退出连接

权限验证

同步数据

**全量复制和增量复制**

全量复制，复制传输RDB文件，从节点接收rdb文件期间的主节点数据积压到缓冲区，后面再同步

部分复制，根据偏移量选择复制，后面复制积压缓冲区

**主从复制模式下，主节点挂了，要人工吧从节点晋升为主节点，并通知应用s方更新主节点地址**

**redis哨兵**

实现主节点故障时，自动故障发现与转移，并通知应用方

一些列哨兵节点与主从节点。

主节点故障，哨兵节点发现故障，选举领导者（哨兵节点）来对主节点进行故障转移。

原理：

**定时任务**、**主观下线和客观下线**、**哨兵领导者选举**、**故障转移**

**定时任务：**

1.每隔10秒，每个哨兵节点向主节点和从节点发送info命令获取最新拓扑关系

2.每隔2秒，哨兵向节点的_sentinel_：hello频道发送该哨兵节点对于主节点的判断以及当前哨兵节点的信息，同时订阅该频道，了解其他哨兵节点及它们对主节点的判断

3.每隔1秒，每个哨兵节点向其他主节点、从节点、哨兵节点发送ping命令做心跳检测，确认是否可达。

**主观下线：**

第三个定时任务超时未收到回应，哨兵节点本身对该节点做失败判定

**客观下线：**

主观下线的是主节点时，向其他哨兵节点询问对主节点的判断，失败判定个数大于阈值，对该主节点客观下线

**领导者选举：**

对主节点客观下线后，选举领导者哨兵节点。

每个哨兵都向其他 哨兵发送命令，要求自己为领导者。

哨兵节点仅同意首次收到的请求命令。

得票大于一定数量，成为领导者。

选举失败，重新选举。

**故障转移：**

从从节点列表中选出一个节点作为新的主节点。（过滤主观下线的、选择从节点优先级搞高的、复制偏移量大的、runid小的）

领导者哨兵节点让该从节点执行 slave of no one 成为主节点

领导者哨兵节点向其他从节点发送命令，成为新主节点的从节点

原主节点更新为从节点，并被保持关注，上线后，同步新的主节点数据

**redis集群**

Redis Cluster作为redis的分布式解决方案

数据分区规则：

哈希分区（redis cluster）和顺序分区（HBASE）

哈希分区分为

 节点取余（节点数量变更时，数据重新迁移，一般2倍式库容，类似hashmap扩容）

一致性哈希分区，为每个节点分配一个0-2^32之间的token，构成一个哈希环，根据key计算hash值，顺时针找到第一个大于等于该hash值的节点，存储数据。

增加删除节点只影响相邻节点。但是在初始节点较少时，节点数量变化影响较大

虚拟槽分区

使用大量虚拟槽容纳数据，每个节点负责一定数量的虚拟槽，redis cluster中虚拟槽数量为16383

**集群后部分功能受限**

key的批量操作

key事务

不支持多数据库空间

复制结构只支持一层

**节点通信**

流言协议：节点不停通信交换信息，一段时间后所有节点都会知道集群完整的信息

meet消息：发送者通知接受者加入集群

ping消息：检测是否在线

pong消息：应答

fail消息：判定某一节点下线时，广播fail消息

**集群节点数量变化**

槽迁移

**请求路由**

键命令先计算对应的槽，再查找槽所在节点（集群内节点通过消息互换获得每个节点的槽信息）

https://segmentfault.com/a/1190000022142261

### 11.RedLock