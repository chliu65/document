# Redis

### 1.redis简介

 **使用 C 语言开发的非关系型数据库，数据存放在内存中，读写速度快，支持事务、持久化、集群等。**

### **2.单线程运行快速的原因**

**纯内存访问**

**IO多路复用，同步非阻塞IO**

**单线程避免了线程切换和线程竞争状态产生的消耗**

### 3.redis的IO多路复用模式

![img](https://images2018.cnblogs.com/blog/1169376/201805/1169376-20180530155238751-909072669.png)

参照上图，简单来说，就是。redis-client在操作的时候，会产生具有不同事件类型。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。

https://blog.csdn.net/longgeqiaojie304/article/details/100941837

io多路复用模式有select、poll、epoll三种模型。redis默认使用epoll.

|            | select             | poll             | epoll                                             |
| ---------- | ------------------ | ---------------- | ------------------------------------------------- |
| 数据结构   | bitmap             | 数组             | 红黑树                                            |
| 最大连接数 | 1024               | 无               | 无                                                |
| FD拷贝     | 每次调用select拷贝 | 每次调用poll拷贝 | fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝 |
| 工作效率   | 轮询：O(n)         | 轮询：O(n)       | 回调：O(1)                                        |

select/poll，把fd（文件描述符）列表从用户态拷贝到内核，遍历，然后返回含有整个句柄的数组。应用程序需要遍历整个数组才能发现哪些句柄发生了事件。**epoll在内核中维护fd列表**（epoll_create创建epoll对象），然后调用epoll_ctl向对象中添加socket连接，调用epoll_wait收集发生的事件连接。**select和poll是将这个内核列表维持在用户态，然后复制到内核态。**

epoll对象使用红黑树存储所有添加到epoll中的事件，双向链表存放通过epoll_wait返回给用户满足条件的事件。

###  **4.过期的数据的删除策略**

1. **惰性删除** ：只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会造成太多过期 key 没有被删除。
2. **定期删除** ： 每隔一段时间抽取一批 key 执行删除过期key操作。并且，Redis 底层会并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。

### 5.Redis 内存淘汰机制

Redis 提供 6 种数据淘汰策略：

1. **volatile-lru（least frequently used）**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. **allkeys-lru（least recently used）**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）
5. **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰
6. **no-eviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！

4.0 版本后增加以下两种：

1. **volatile-lfu**：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰
2. **allkeys-lfu**：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key

### 6.持久化机制

##### RDB

把当前进程数据生成快照文件保存在硬盘。

流程：

生成快照文件执行bgsave，父进程判断是否有正在进行持久化操作的子进程，有的话直接返回。

父进程fork出一个子进程，此期间父进程读写数据阻塞

子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后原子替换原RDB文件，此期间父进程接收客户端读写请求。

子进程发送完成信号。

优点：加载快

##### **AOF**

以独立日志的形式记录写命令，恢复时重新执行写命令。

命令写入→文件同步→文件重写→重启加载

AOF重写：

随着命令不断写入，AOF文件越来越大，需要重写以压缩文件体积。

如果当前正在AOF重写，则返回。

fork子进程，父进程阻塞。

子进程重写AOF，父进程接收客户端指令，并将指令存储到重写缓存区。

子进程完成AOF重写，将缓存区内容添加到AOF文件末尾。替换 原AOF文件

**混合持久化**

RDB写在AOF的开头

### 7.基础数据结构

**内部数据结构**

dict、sds、skiplist、quicklist、ziplist



  **跳表**

解决普通链表查找慢的问题，时间复杂度对数级

由多个层的链表组成，查询时从高层往低层查找。

每个节点随机出一个层数

### 8.缓存穿透与缓存雪崩

**缓存穿透**大量无效key穿过redis打到数据库

业务层校验

可以缓存无效key或布隆过滤器

**缓存雪崩**：大量key同时失效或节点宕机

设置过期时间随机

高可用

**缓存击穿**：热点key失效同时，大量请求打到数据库

设置永不过期

定时更新

互斥锁（常用方案）根据key获取的value为空时，先锁上，然后从数据库加载到redis再释放锁。其他线程在请求key时，获取锁失败则睡眠一段时间后重试。

### 9.redis高可用

##### **redis主从复制**

复制过程：

从节点执行slaveof指令，从节点保存主节点地址信息ip+port。

从节点与主节点建立socket连接

发送ping命令，无反应则退出连接

权限验证

同步数据

**全量复制和增量复制**

全量复制，复制传输RDB文件，从节点接收rdb文件期间的主节点数据积压到缓冲区，后面再同步

部分复制，根据偏移量选择复制，后面复制积压缓冲区

**主从复制模式下，主节点挂了，要人工把从节点晋升为主节点，并通知应用方更新主节点地址**

##### **redis哨兵**

实现主节点故障时，自动故障发现与转移，并通知应用方

一系列哨兵节点与主从节点。

主节点故障，哨兵节点发现故障，选举领导者（哨兵节点）来对主节点进行故障转移。

原理：

**定时任务**、**主观下线和客观下线**、**哨兵领导者选举**、**故障转移**

**定时任务：**

1.每隔10秒，每个哨兵节点向主节点和从节点发送info命令获取最新拓扑关系

2.每隔2秒，哨兵向节点的_sentinel_：hello频道发送该哨兵节点对于主节点的判断以及当前哨兵节点的信息，同时订阅该频道，了解其他哨兵节点及它们对主节点的判断

3.每隔1秒，每个哨兵节点向其他主节点、从节点、哨兵节点发送ping命令做心跳检测，确认是否可达。

**主观下线：**

第三个定时任务超时未收到回应，哨兵节点本身对该节点做失败判定

**客观下线：**

主观下线的是主节点时，向其他哨兵节点询问对主节点的判断，失败判定个数大于阈值，对该主节点客观下线

**领导者选举：**

对主节点客观下线后，选举领导者哨兵节点。

每个哨兵都向其他 哨兵发送命令，要求自己为领导者。

哨兵节点仅同意首次收到的请求命令。

得票大于一定数量，成为领导者。

选举失败，重新选举。

**故障转移：**

从从节点列表中选出一个节点作为新的主节点。（过滤主观下线的、选择从节点优先级高的、复制偏移量大的、runid小的）

领导者哨兵节点让该从节点执行 slave of no one 成为主节点

领导者哨兵节点向其他从节点发送命令，成为新主节点的从节点

原主节点更新为从节点，并被保持关注，上线后，同步新的主节点数据

##### **redis集群**

Redis Cluster作为redis的分布式解决方案

数据分区规则：

哈希分区（redis cluster）和顺序分区（HBASE）

哈希分区分为

 **节点取余**

节点数量变更时，数据重新迁移，一般2倍式库容，类似hashmap扩容，节点数量变化时，所有的键都需要重新计算。

**一致性哈希分区**

为每个节点分配一个0-2^32之间的token，构成一个哈希环，根据key计算hash值，顺时针找到第一个大于等于该hash值的节点，存储数据。

增加删除节点只影响相邻节点。但是在初始节点较少时，节点数量变化影响较大

**虚拟槽分区**

使用大量虚拟槽容纳数据，每个节点负责一定数量的虚拟槽，redis cluster中虚拟槽数量为16383。

所有的键根据hash函数映射到槽内，

**集群后部分功能受限**

key的批量操作

key事务

不支持多数据库空间

复制结构只支持一层

**节点通信**

流言协议：节点不停通信交换信息，一段时间后所有节点都会知道集群完整的信息

meet消息：发送者通知接受者加入集群

ping消息：检测是否在线

pong消息：应答

fail消息：判定某一节点下线时，广播fail消息

**集群节点数量变化**

槽迁移

**请求路由**

键命令先计算对应的槽，再查找槽所在节点（集群内节点通过消息互换获得每个节点的槽信息）

https://segmentfault.com/a/1190000022142261

### 10.事务

Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的

1.redis 不支持回滚“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。
2.如果在一个事务中的**命令**出现错误，那么**所有的命令**都不会执行；
3.如果在一个事务中出现**运行错误**，那么**正确的命令**会被执行。
注：redis的discard只是结束本次事务,正确命令造成的影响仍然存在.

### 11.RedLock

### 12.面试题

https://blog.csdn.net/Butterfly_resting/article/details/89668661