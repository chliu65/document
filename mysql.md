# MySQL

### 1.简介

MySQL 是一种关系型数据库，在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。默认端口号3306

### **2.名词释义**

**索引：用于快速进行数据查找的数据结构，MySQL常用索引有b+树索引（查询速度稳定）和hash索引（快，不适合范围查询）**

**联合索引：MySQL可以使用多个字段同时建立一个索引,叫做联合索引.在联合索引中,如果想要命中索引,需要按照建立索引时的字段顺序挨个使用,否则无法命中索引.**

### **3.索引**

**b+树索引**

b+树与b树区别

b树中间节点存放键与值，b+树只存放键（一次读取可以在内存页中获取更多的键）。叶子节点存放值。并且b+树的叶子节点之间有一条链相连（有利于范围查找）。

**hash索引**

- hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。
- hash索引不支持使用索引进行排序，原理同上。
- hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。
- hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。
- hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。

**联合索引**

https://www.cnblogs.com/ljl150/p/12934071.html

联合索引的底层也就是一颗B+树，只不过联合索引的B+树节点中存储的是键值。由于构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建。

创建一个（a,b）的联合索引，那么它的索引树就是下图的样子。

![img](https://img2020.cnblogs.com/blog/1804577/202005/1804577-20200521182659976-48843100.png)

**聚集索引**

将数据存储与索引放到了一块，找到索引也就找到了数据



### 4.日志

#####  MySQL的binlog有有几种录入格式?分别有什么区别?

有三种格式,statement,row和mixed.

- statement模式下,记录单元为语句.即每一个sql造成的影响会记录.由于sql的执行是有上下文的,因此在保存的时候需要保存相关的信息,同时还有一些使用了函数之类的语句无法被记录复制.
- row级别下,记录单元为每一行的改动,基本是可以全部记下来但是由于很多操作,会导致大量行的改动(比如alter table),因此这种模式的文件保存的信息太多,日志量太大.
- mixed. 一种折中的方案,普通操作使用statement记录,当无法使用statement的时候使用row.

此外,新版的MySQL中对row级别也做了一些优化,当表结构发生变化的时候,会记录语句而不是逐行记录.

### 5.基本数据类型

| **分类**             | **类型名称** |                           **说明**                           |
| -------------------- | ------------ | :----------------------------------------------------------: |
| **整数类型**         | tinyInt      |                    很小的整数(8位二进制)                     |
|                      | smallint     |                     小的整数(16位二进制)                     |
|                      | mediumint    |                  中等大小的整数(24位二进制)                  |
|                      | int(integer) |                  普通大小的整数(32位二进制)                  |
|                      | bigint       |                             64位                             |
| **小数类型**         | float        |                         单精度浮点数                         |
|                      | double       |                         双精度浮点数                         |
|                      | decimal(m,d) |                       压缩严格的定点数                       |
| **日期类型**         | year         |                        YYYY 1901~2155                        |
|                      | time         |                HH:MM:SS -838:59:59~838:59:59                 |
|                      | date         |               YYYY-MM-DD 1000-01-01~9999-12-3                |
|                      | datetime     | YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59 |
|                      | timestamp    | YYYY-MM-DD HH:MM:SS 19700101 00:00:01 UTC~2038-01-19 03:14:07UTC |
| **文本、二进制类型** | CHAR(M)      |                      M为0~255之间的整数                      |
|                      | VARCHAR(M)   |                     M为0~65535之间的整数                     |
|                      | TINYBLOB     |                      允许长度0~255字节                       |
|                      | BLOB         |                     允许长度0~65535字节                      |
|                      | MEDIUMBLOB   |                   允许长度0~167772150字节                    |
|                      | LONGBLOB     |                   允许长度0~4294967295字节                   |
|                      | TINYTEXT     |                      允许长度0~255字节                       |
|                      | TEXT         |                     允许长度0~65535字节                      |
|                      | MEDIUMTEXT   |                   允许长度0~167772150字节                    |
|                      | LONGTEXT     |                   允许长度0~4294967295字节                   |
|                      | VARBINARY(M) |              允许长度0~M个字节的变长字节字符串               |
|                      | BINARY(M)    |              允许长度0~M个字节的定长字节字符串               |



### 9.优化

**尽量避免null**

定位sql语句执行缓慢的原因

.https://blog.csdn.net/ThinkWon/article/details/104778621/

##### 大表数据查询，怎么优化

### **10.其他**

##### **三大范式**

第一范式: 每个列都不可以再拆分. 

第二范式: 非主键列完全依赖于主键,而不能是依赖于主键的一部分. 

第三范式: 非主键列只依赖于主键,不依赖于其他非主键. 

# InnoDB

### 2.存储引擎对比

MyISAM和InnoDB

InnoDB支持行锁、MVCC、事务、支持外键。

MyISAM使用表锁，不支持事务和外键，支持全文索引。缓冲池只缓存索引文件，不缓存数据文件。

###### 索引对比

- InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。
- InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。
- MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。
- InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。

### 3.innodb体系结构

后台线程、内存

内存中的缓冲池：

读取页操作时，将磁盘读到的页数据放到缓冲池，下一次命中缓冲池时，直接读取缓冲池。更新时，先更新缓冲池，再刷新到数据库（checkpoint）。

缓冲池中缓存：索引页、数据页、undo页、插入缓冲、自适应哈希索引、锁信息、数据字典信息。

使用LRU对缓冲池做内存管理

**checkpoint**

用于缩短数据库的恢复时间、缓冲池不够用时，刷新脏页到磁盘、重做日志不可用时，刷新脏页

### 4.innodb关键特性

**插入缓冲**

针对使用辅助索引插入数据费时间的问题，如果缓冲池没有命中索引页，先把数据放入insert buffer中，然后以一定频率合并到辅助索引页。该辅助索引不能是唯一索引

**两次写**

对缓冲池脏页刷新到磁盘时，不直接写磁盘，先复制到doublewrite buffer，doublewrite buffer分两次分别写入共享表空间的物理磁盘和磁盘，

**自适应哈希索引**

**异步IO**

### 5.表

**主键**

不指定则：先判断是否有非空的唯一索引，否则自动创建主键

**逻辑存储结构**

所有数据逻辑的放在表空间，表空间→段→区→页

表空间存放数据，索引，插入缓冲bitmap页

### 6.索引

innode使用b+树索引

b树、b+树区别

b+树仅在叶子节点存放数据，所以每次查询操作都要走到叶子阶段。

b+树索引仅能找到被查找舒张所在数据页，然后把页读到内存，再查询。

聚集索引和非聚集索引都使用b+树，非聚集索引叶子节点存放的是对应的聚集索引。

### 7.锁机制

管理对共享资源的并发访问

**lock和latch**

锁和闩（锁的时间很短，没有死锁检查机制）

锁分为共享锁和排它锁

**一致性非锁定读**

通过行多版本控制的方式读取当前执行时间数据库中行的数据。如果读取的行正在执行delete或update，**不会等待行上的锁释放，而是读取一个快照版本。**在read commit隔离级别下，读取的是最新的快照版本。repeatable read隔离级别下读取的是事务开始前快照版本。

**一致性锁定读**

在需要对读取的操作加锁以确保数据逻辑一致性。

**自增长与锁**

为了提高插入的并发性能，锁不是在事务完成后释放，而是完成后对自增长值插入的SQL语句后立即释放。

**锁算法**

行锁、间隙锁、next-key lock（行锁+间隙锁，锁定一个范围，包含记录本身）

**死锁**

两个或以上事务在执行过程中，因争夺锁资源而陷入互相等待的现象。

数据库使用等待图进行死锁检测。在事务请求锁并发生等待时，判断是否存在回路，如果存在在有死锁，回滚undo量最小的事务。

### **8.事务**

逻辑上不可分割的一组操作

事务的四大特性

ACID

原子性、一致性、隔离性以及持久性。

**事务隔离级别**

##### 隔离级别与锁的关系

在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突

在Read Committed级别下，读操作需要加共享锁，但是**在语句执行完以后释放共享锁**；

在Repeatable Read级别下，读操作需要加共享锁，但是**在事务提交之前并不释放共享锁**，也就是必须等待事务执行完毕以后才释放共享锁。

SERIALIZABLE 是限制性最强的隔离级别，因为该级别**锁定整个范围的键**，并一直持有锁，直到事务完成。

**事务分类**

扁平事务、带有保存点的扁平事务、连事务、嵌套事务、分布式事务。

扁平事务：普通事务，全执行或全回滚。

带有保存点的：允许回滚到同一事务中较早的一个状态，保存点 会随着系统崩溃而丢失。

链事务：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式传给下一个开始的事务。提交与开启下一事务为一原子操作。

**事务实现**

redo log保证事务的原子性和持久性，undo log保证事务的一致性。

redo记录页的物理修改操作，undo是逻辑日志，

**redo**

事务提交时，将事务的所有日志写入到重做日志文件进行持久化，才算完成提交。

**undo**

undo存放在数据库内部undo段，位于共享表空间。undo用于将数据库逻辑的恢复到原来的样子。

# 面试题

##### 1.**一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？**

使用myisam，是18，使用innodb是15.myisam会把自增逐渐的最大id就到数据文件。innodb只是把自增主键的最大id记录到内存。重启丢失。

##### 2.**Heap表是什么？**

HEAP表存在于内存中，用于临时高速存储。

- BLOB或TEXT字段是不允许的
- 只能使用比较运算符=，<，>，=>，= <
- HEAP表不支持AUTO_INCREMENT
- 索引不可为NULL

##### 3.**区分CHAR_LENGTH和LENGTH？**

CHAR_LENGTH是字符数，而LENGTH是字节数。Latin字符的这两个数据是相同的，但是对于Unicode和其他编码，它们是不同的。

##### 4.百万级别或以上的数据如何删除

先删除索引，然后删除无用数据，重新创建索引。

##### 5.什么是最左前缀原则？什么是最左匹配原则

- 在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。
- 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
- =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

##### 6.数据库为什么使用B+树而不是B树

- B树只适合随机检索，而B+树同时支持随机检索和顺序检索；
- B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；
- B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。
- B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。
- 增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。

##### 7.varchar与char的区别

**char的特点**

- char表示定长字符串，长度是固定的；
- 如果插入数据的长度小于char的固定长度时，则用空格填充；
- 因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；
- 对于char来说，最多能存放的字符个数为255，和编码无关

**varchar的特点**

- varchar表示可变长字符串，长度是可变的；
- 插入的数据是多长，就按照多长来存储；
- varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；
- 对于varchar来说，最多能存放的字符个数为65532